---
title: Fix massive amounts of TypeScript on project with strong legacy
publishDate: 20 jan 2024
description: When onboarding on a new TypeScript project you might encounter strong legacy due to too permissive configuration or not idiomatic implementation, in this article we see my approach to handle them.
---

import BaseAnchor from "../../components/kit/BaseAnchor.astro";

## <BaseAnchor label="Table of contents"/>

- [Table of contents](#table-of-contents)
- [TL;DR](#tldr)

## <BaseAnchor label="TL;DR" />

TODO WIP

## <BaseAnchor label="Introduction" />

Lets say we've just landed on a new job or we're just given the responsibility of an existing TypeScript application, either client or server.
Giving a look to the `tsconfig` you see this:

```json
{
  // ...
  "compilerOptions": {
    "strict": false,
    "strictNullChecks": false,
    "strictPropertyInitialization": false,
    "skipLibCheck": true,
    "noImplicitAny": false
    // ...
  }
}
```

From there if you're working on an Node.js API I would be personally very worried of the server'security potential data leakage and consistency.
Anyway, your goal is to enhance, by activating TypeScript strictness on this application.

## "strict"

Mainly activating this flag will disable or enable the below flags depending if they're giving or skipping strictness

## "strictNullChecks"

In my opinion this the most important one, this intensifies the others "bad" flags
Such operations does not raise any ts errors anymore:

```ts
interface Foo {
  bar: string;
}

const toto: Foo = undefined;
const titi: Foo = {};

// Reading the references
console.log(titi.bar);
```

## "strictPropertyInitialization"

By activating this flag no need to assign `class` properties just after declaration.
Commonly found on `NestJs` when declaring model.
Combined with the `strictNullChecks` this can be really dangerous leading to unhandled behavior.

# "skipLibCheck"

Might be really legitimate to be used depending on the project, but before activating this still have a look to your types peer dependencies.

```ts
class Foo {
  bar: string;

  constructor(value: string | null) {
    // here at runtime this.bar can either be undefined null or a string
    this.bar = value;
  }
}
```

## <BaseAnchor label="The diagnostic" />

First of all we have to determine the proportions of the task. It will depends on several factors such as the application size, global implementation paradigm ( imperative or declarative ) also is the application strongly tested ?
Lets activate toggle all of your problematic flags and run `tsc --noEmit`.
Note that just like a train a TypeScript might hide an other one.
The amount of errors might be misleading but it still gives a pretty good overview of the work to be done.

```sh
Found 8987 errors in 716 files.

Errors  Files
     #...
```

Now it's up to you to estimate the cost of manual fix of the errors.
Seeing the quantity of them this is not something we wanna fix manually even incrementally or even one day.
What I mean is that developers cannot, for budget or even human capacity all focus on this kind of task.
But can be set good practices to avoid introducing new legacy but also specific refactor/enhancement to allow a better global strictness.

## <BaseAnchor label="My spec" />

### <BaseAnchor label="Deadcode" />

Something we don't wanna do is loosing time of fixing errors on unused code. Such as outdated mocks or so.
To do so we can use great tools such as [knip](https://knip.dev/) that will detect unused:

- files
- dependencies
- exports
- unused types
  and more !

Removing deadcode is IMO a pretty descent first step

### <BaseAnchor label="Avoid regression / Confidence in the refactor" />

This might sound quite paradoxical due to TypeScript nature, but yes fixing TypeScript issues might bring functional regression on stabilized bugs.
This is why it's really important to take time to understand the section's business logic you're refactoring.
Also I would recommend, if it's not already the case to implement user oriented tests, such as integration or e2e. To attest the application's status before starting fixing ts-errors.

Note that unit tests might false positive, as you will have to fix type issues on them that can lead to previously untested behavior. Where as integration/e2e tests should not be requiring such a deep refactor if it's not the mocked data.

### <BaseAnchor label="Refactor the contract API" />

### <BaseAnchor label="New development" />

Activating the flags for a given folder or file with specific extension ?
Enable tsc compilation in cicd to avoid nut maintaining tests and mocks
