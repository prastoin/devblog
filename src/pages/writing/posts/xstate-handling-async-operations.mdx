---
layout: ../../../layouts/WritingLayout.astro
title: Handling async operations, invoking promises with XState
publishDate: 12 oct 2022
name: prastoin
description: Thanks to XState invoke and parallel states, we're able to TODO
---

import BaseAnchor from '../../../components/kit/BaseAnchor.astro';

## <BaseAnchor label="Table of contents"/>

-   [Table of contents](#table-of-contents)
-   [Introduction](#introduction)

## <BaseAnchor label="Introduction" />

The very first need is two await for two async source to finish before going further.
Lets say for the example, waiting for the response of 2 http requests before allowing the user to interact with the view.
In our example we'll take both the `UserInformation` and `UserCart` requests.

A State Machine defines `States` listening to `Events` allowing or not `Transitions` to other `States` it also contains a `Context`.
It exists several layers where we can run specific `Actions`, `Services` and `Conditions`, as for example when entering/leaving a `State` or receiving a specific `event` and more.
XState is a library that allows us to write States machines in Javascript. It comes with a lot a framework related packages, such as React Vue Angular and more, to be able to interact and interpret the logic a machine can be carrying from any view.

The goal of our application is then to load all the user Data, before achieving to its final state.
To do so we'll be using the [Invoking promises](https://xstate.js.org/docs/guides/communication.html#invoking-promises) XState's feature and XState [parallel states](https://xstate.js.org/docs/guides/parallel.html).

## <BaseAnchor label="Invoking promises with XState"/>

XState thanks to its `Invoke` API, allows us to invoke Callbacks/Machines/Observables/Promises.
In our case we will be invoking promises, and more precisely services leagind to send an http request.
Lets think about a machine that when being interpreted instantly send an HTTP request to a server in order to retrieve a user instance.
That machine will need to have an initial state set to the state that invoked our fetching promise, lets say `Loading`.
In that state thanks to `invoke` we will run our fetch instance, then within the same state we will ended either the failing and success use case.
Using the `onDone` and `onError` properties, that respectively handle the promise resolution and promise rejection.
In a success case we will transition to a `success` state, otherwise in a `failure` state.
Lets be fancy ! Inside the `failure` state we will listen for a `RETRY` event, only available when we're in this state ! On its reception we will transition to the `loading` state.
In this example I use the XState typegen to be able to strongly type any of my machine properties.

Simple typed usage example:

```ts
import { assign, createMachine } from 'xstate';

interface User {
    userId: number;
    userEmail: string;
}

const fetchUser = (userId: number): Promise<User> =>
    fetch(`url/to/user/${userId}`).then((response) => response.json());

interface FetchUserMachineContext {
    userId: number;
    userEmail?: string;
}

// Machine definition
export const userMachine = createMachine(
    {
        id: 'user',
        // The default state the machine will join
        initial: 'loading',
        schema: {
            context: {} as FetchUserMachineContext,
            services: {} as {
                'Fetch User': {
                    data: User;
                };
            },
        },
        // This is for typing purpose for more information have a look to
        // https://xstate.js.org/docs/guides/typescript.html#typegen
        tsTypes: {} as import('./myTestMachine.typegen').Typegen0,
        context: {
            userId: 42,
            userEmail: undefined,
        },
        states: {
            loading: {
                // From the moment the machine is interpreted it will triggers the following invoke
                // That leads to perform an HTTP request
                invoke: {
                    id: 'getUser',
                    src: 'Fetch User',

                    // On promise resolution
                    onDone: {
                        target: 'success',
                        // If the response is ok then we will update the machine context from the retrieved data using an action
                        actions: 'Assign fetched user to context',
                    },

                    // On promise Rejection
                    onError: {
                        target: 'failure',
                    },
                },
            },

            success: {
                type: 'final',
            },

            failure: {
                // In this state we're listening to a specific event RETRY
                // Note that if the machine intercepts a RETRY event while being in loading state
                // It won't be interpreted at all
                on: {
                    RETRY: { target: 'loading' },
                },
            },
        },
    },
    {
        actions: {
            // Note thanks to the typegen we don't even have to type check the received event below !
            'Assign fetched user to context': assign({
                userEmail: (_context, event) => event.data.userEmail,
            }),
        },
        services: {
            'Fetch User': async (context) => await fetchUser(context.userId),
        },
    },
);
```

Note that just like that, when the machine is not interpreted ! It's just an object.
We will see later a way to interpret an equivalent machine later.

## <BaseAnchor label="parallel states nodes"/>

We've seen how to handle one async operation within a state machine. But our goal is to be handling at least two of them at the same time.
In this way we will need our machine to be able to "be" in several states at once.
This is when the `parallel` states nodes make an entrance.
It exists several machine [states node types](https://xstate.js.org/docs/guides/statenodes.html#state-node-types):

```
- An atomic state node has no child states. (I.e., it is a leaf node.)
- A compound state node contains one or more child states, and has an initial state, which is the key of one of those child states.
- A parallel state node contains two or more child states, and has no initial state, since it represents being in all of its child states at the same time.
- A final state node is a leaf node that represents an abstract "terminal" state.
- A history state node is an abstract node that represents resolving to its parent node's most recent shallow or deep history state.
```

From there we can imagine an example machine that would lead to start within 2 parallel states that both waits for a specific events to transition to their final state.
Lets say a very first parent state that will have two states child, one being the parallel states handler and the other being the machine final state nor further logic.
Inside the parallel machine will be found two parralel states waiting for their specific ressources, here 1 and 2, to be fulfilled, when it's the case they will transition to their final states.
A parallel parent state can listen to the final state transition of every of his parallel child states through the [onDone](https://xstate.js.org/docs/guides/final.html#parallel-states) property.

```ts
import { createMachine } from 'xstate';

type ParallelMachineExampleEvents =
    | {
          type: 'User fulfilled ressource 1';
      }
    | {
          type: 'User fullfilled ressource 2';
      };

export const machine = createMachine({
    id: 'parallel machine example',
    schema: {
        events: {} as ParallelMachineExampleEvents,
    },
    // This is for typing purpose for more information have a look to
    // https://xstate.js.org/docs/guides/typescript.html#typegen
    tsTypes: {} as import('./myTestMachine.typegen').Typegen0,
    initial: 'Pending until user fulfilled all required ressources',
    states: {
        'Pending until user fulfilled all required ressources': {
            type: 'parallel',
            // The onDone property we'll be triggered when every child states reach to their final state
            onDone: 'All ressources has been fulfilled by the user',
            // We do not declare any initial state there as the machine is in every child states at once

            states: {
                'Ressource 1 handler': {
                    type: 'compound',
                    initial: 'Waiting for user input',

                    states: {
                        'Waiting for user input': {
                            on: {
                                'User fulfilled ressource 1': {
                                    target: 'Success',
                                },
                            },
                        },

                        // Ressource 1 handler final state is Success
                        Success: {
                            type: 'final',
                        },
                    },
                },

                'Ressource 2 handler': {
                    type: 'compound',
                    initial: 'Waiting for user input',

                    states: {
                        'Waiting for user input': {
                            on: {
                                'User fullfilled ressource 2': {
                                    target: 'Success',
                                },
                            },
                        },

                        // Ressource 2 handler final state is also Success
                        Success: {
                            type: 'final',
                        },
                    },
                },
            },
        },

        'All ressources has been fulfilled by the user': {
            // The machine reaches its global final state
            type: 'final',
        },
    },
});
```

Note that again, we've haven't seen how to interact with the machine from the outside, such as sending it events.
We're going to see this in the section just below ! where we use both `XState` parallel states and `Promises invocation`.

## <BaseAnchor label="Both together"/>

Just as a reminder in the introduction section we've listed that our need was to await for two async source to finish before going further, taking as an example a `UserCart` and `UserInformation` loading from server endpoints.
Our machine will then need to:

In it's initial first state `Idle`, listen for an event to transition to a `loading` parallel state.
In this `loading` parallel state will be defined two parallel states that will both invoke a specific service, both being `UserCart` or `UserInformation` fetching functions.
The `loading` state on it's `onDone` property, when all its children are in final states, will transition to a `loaded` state.
As we can see our machine states are quite long sentences. This is not mandatory but I really like this ability to give sense to the code by it's definition.
Whatever is your business logic or your need, you can totally describe what state is expecting and used for.
Also note that thanks to the typegen the autocompletion is even more allowing it.

In the following example nothing new !
The idea is the same as the other above example codes. We put in parallel states that invoke promises.
On every promises validation we transtition thanks to the parent parallel state node `onDone` property to a final state.
Note that the "Fetch user cart" and "Fetch user information" services are not defined within the machine configuration, when interpreting the machine we will have to provide them to the configuration.
Their definition doesn't relate to the machine itself, it's recommended to think about a machine as a pure entity without specific dependencies.
In this way we could integrate this machine anywhere.

```ts
import type { UserCart, UserInformation } from "@/type";
import { assign, createMachine } from "xstate";

type LoadUserDataMachineEvents =
  | {
      type: "User pressed load user data button";
    }
  | {
      type: "User pressed reset machine button";
    };

type LoadUserDataMachineContext = {
  userInformation?: UserInformation;
  userCart?: UserCart;
};

export const createLoadUserDataMachine = () => {
  return createMachine(
    {
      id: "loadUserDataMachine",
      tsTypes: {} as import("./LoadUserDataMachine.typegen").Typegen0,
      schema: {
        services: {} as {
          "Fetch user information": {
            // The data that gets returned from the service
            data: UserInformation;
          };
          "Fetch user cart": {
            data: UserCart;
          };
        },
        events: {} as LoadUserDataMachineEvents,
        context: {} as LoadUserDataMachineContext,
      },
      context: {
        userInformation: undefined,
        userCart: undefined,
      },
      initial: "Idle",
      states: {
        Idle: {
          on: {
            "User pressed load user data button": {
              target: "Load user data",
            },
          },
        },

        "Load user data": {
          type: "parallel",
          onDone: {
            target: "Loaded user data",
          },

          states: {
            "Loading user information": {
              initial: "Fetching user information from server",

              states: {
                "Fetching user information from server": {
                  tags: "Loading user information",

                  invoke: {
                    src: "Fetch user information",

                    onDone: {
                      target: "Loaded user information",
                      actions: "Assign loaded user information to context",
                    },

                    onError: {
                      target: "Loading user information failed",
                    },
                  },
                },

                "Loading user information failed": {
                  tags: "Loading user information failed",
                  on: {
                    "User pressed load user data button": {
                      target: "Fetching user information from server",
                    },
                  },
                },

                "Loaded user information": {
                  type: "final",
                },
              },
            },

            "Load user cart": {
              initial: "Fetching user cart from server",
              states: {
                "Fetching user cart from server": {
                  tags: "Loading user cart",

                  invoke: {
                    src: "Fetch user cart",

                    onDone: {
                      target: "Loaded user cart",
                      actions: "Assign loaded user cart to context",
                    },

                    onError: {
                      target: "Loading user cart failed",
                    },
                  },
                },

                "Loading user cart failed": {
                  tags: "Loading user cart failed",
                  on: {
                    "User pressed load user data button": {
                      target: "Fetching user cart from server",
                    },
                  },
                },

                "Loaded user cart": {
                  type: "final",
                },
              },
            },
          },
        },

        "Loaded user data": {
          on: {
            "User pressed reset machine button": {
              target: "#loadUserDataMachine.Idle",
              actions: "Reset machine context",
            },
          },
        },
      },
    },
    {
      actions: {
        "Assign loaded user information to context": assign({
          userInformation: (_context, event) => {
            return event.data;
          },
        }),
        "Assign loaded user cart to context": assign({
          userCart: (_context, event) => {
            return event.data;
          },
        }),

        "Reset machine context": assign({
          userCart: (_context, _event) => undefined,
          userInformation: (_context, _event) => undefined,
        }),
      },
    }
  );
};
```
        },
    },
});
```
Note that again we've haven't seen how to interact with the machine from the outside, in our precise case how to send events to it.
We're going to see this in the section just below ! where we use both `XState` parallel states and `Promises invocation`